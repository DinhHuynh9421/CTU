#include<stdio.h>

#define INF 999999
#define MAXN 100
#define No_edge -1
typedef struct{
	int A[MAXN][MAXN];
	int n,m;
}Graph;

void init_graph(Graph *G, int n){
	int i,j;
	G->n = n;
	G->m = 0;
	for(i = 1; i <= n; i++){
		for(j = 1; j <= n; j++){
			G->A[i][j] = INF;
		}
	}
}
void add_edge(Graph *G, int x, int y, int w){
	G->A[x][y] = w;
	G->A[y][x] = w;
	G->m++;
}

int mark[MAXN];
int pi[MAXN];
int p[MAXN];

void Dijkstra(Graph *G, int s){
	int i,j,e;
	for(i = 1; i <= G->n; i++){
		mark[i] = 0;
		pi[i] = INF;
	}
	pi[s] = 0;
	p[s] = -1;
	
	for(e = 1; e < G->n; e++){
		int min_pi = INF;
		for(j = 1; j <= G->n; j++){
			if(mark[j] == 0 && pi[j] < min_pi){
				min_pi = pi[j];
				i = j;
			}
		}
		mark[i] = 1;
		for(j = 1; j <= G->n; j++){
			if(G->A[i][j] != No_edge && mark[j] == 0){
				if(pi[i] + G->A[i][j] <  pi[j]){
					pi[j] =  pi[i] + G->A[i][j];
					p[j] = i;
				}
			}
		}
	}
}
void printPath(int x, int y){
	if(x == y){
		printf("%d ",x);
	}else if(p[y] == -1){
		printf("Khong co duong di tu %d den %d\n", x, y);
	}else {
		printPath(x, p[y]);
		printf("%d ",y);
	}
}
int main(){
	//freopen("jonh.txt","r",stdin);
	Graph G;
	int n,m;
	scanf("%d%d",&n,&m);
	init_graph(&G, n);
	int i;
	for(i = 0; i < m; i++){
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		add_edge(&G, u, v, w);
	}
	int x, y;
	scanf("%d%d",&x, &y);
	Dijkstra(&G, x);
	printf("%d\n", pi[y]);
	printPath(x, y);
	
	return 0;
}
//cau5
  
  
  //cau1
#include<stdio.h>
#define MAX_Vertices 100

typedef struct{
	int n,m;
	int A[MAX_Vertices][MAX_Vertices];
}Graph;

void init_graph(Graph *G, int n){
	G->n = n;
	int i,j;
	for(i = 1; i <= G->n; i++){
		for(j = 1; j <= G->n; j++){
			G->A[i][j] =0;
		}
	}
}

void add_edge(Graph *G, int x, int y){
	G->A[x][y] += 1;
	G->m++;
}
int degree(Graph *G, int x){
	int deg = 0;
	int i;
	for(i = 1; i <= G->n; i++){
		if(G->A[i][x] > 0){
			deg+=G->A[i][x];
		}
	}
	return deg;
}

int main(){
	Graph G;
	int n;
	scanf("%d",&n);
	init_graph(&G, n);
	int i,j;
	for(i = 1; i <= n; i++){
		for(j = 1; j <= n; j++){
			int a;
			scanf("%d ", &a);
			int e;
			for(e = 0; e < a; e++){
				add_edge(&G, i,j);
			}
		}
	}

	int max = 0, index = 0;
	for(i = 1; i <= n; i++){	
		if(max < degree(&G,i)){
			max = degree(&G,i);
			index = i;
		}			
	}
	printf("%d has received %d email(s).", index,max);

	return 0;
}

//cau 4
#include<stdio.h>

#define MAX_Vertices 100

typedef struct{
	int A[MAX_Vertices][MAX_Vertices];
	int n,m;
}Graph;

void init_graph(Graph *G, int n){
	G->n = n;
	int i,j;
	for(i = 1; i <= G->n; i++){
		for(j = 1; j <= G->n; j++){
			G->A[i][j] = 0;
		}
	}
}
void add_edge(Graph *G, int x,int y){
	G->A[x][y] = 1;
	G->m++;
}
int adjacent(Graph *G, int x, int y){
	return G->A[x][y];
}
void inDegree(Graph *G, int x){
	int deg = 0;
	int i;
	for(i = 0; i < G->n; i++){
		if(adjacent(G, i, x))deg++;
	}
	printf("%d:%d\n",x, deg);
}

int main(){
	Graph G;
	int n,m, u, v,x;
	
	scanf("%d%d", &n,&m);
	init_graph(&G, n);
	int i;
	for(i = 1; i <= m; i++){
		scanf("%d%d",&u,&v);
		add_edge(&G, u, v);
	}	
	
	scanf("%d",&x);
	inDegree(&G, x);
	return 0;
}

//cau6
#include<stdio.h>

#define MAX_N 100
#define No_Edge -1
#define oo 999999

typedef struct{
	int A[MAX_N][MAX_N];
	int n,m;
}Graph;

void init_graph(Graph *G, int n){
	G->n = n;
	G->m = 0;
	int i,j;
	for(i = 1; i <= G->n; i++){
		for(j = 1; j <= G->n; j++){
			G->A[i][j] = No_Edge;
		}
	}
}

void add_edge(Graph *G, int u, int v, int w){
	G->A[u][v] = w;
	G->A[v][u] = w;
	G->m++;
}
int pi[MAX_N];
int p[MAX_N];
int mark[MAX_N];
int check = 0;
int Prim(Graph *G, Graph *T, int x){
	int u,v,i;
	for(u = 1; u <= G->n; u++){
		mark[u] = 0;
		pi[u] = oo;
		p[u] = -1;
	}
	pi[x] = 0;
	for(i = 1; i < G->n; i++){
		int min_pi = oo;
		for(v = 1; v <= G->n; v++){
			if(mark[v] == 0 && pi[v] < min_pi){
				min_pi = pi[v];
				u = v;
			}
		}
		mark[u] = 1;
		for(v = 1; v <= G->n; v++){
			if(G->A[u][v] != No_Edge && mark[v] == 0){
				if(G->A[u][v] < pi[v]){
					pi[v] = G->A[u][v];
					p[v] = u;
				}
			}
		}
	}
	
	init_graph(T, G->n);
	int sum_w = 0;
	for(u = 1;  u <= G->n; u++){
		if(p[u] != -1){
			add_edge(T, p[u], u, G->A[p[u]][u]);
			sum_w += G->A[p[u]][u];
			check++;
		}
	}
	return sum_w;
}

int main(){
	Graph T, G;
	int n,m,u,v,x,y,e;
	//freopen("BacBaPhi.txt","r",stdin);
	scanf("%d%d",&n,&m);
	init_graph(&G, n);
	
	for(e = 1; e <= m; e++){
		scanf("%d%d%d%d",&u,&v,&x,&y);
		add_edge(&G, u, v, x*y);
	}	
	int sum = Prim(&G, &T,1);
	if(check == G.n-1){
		printf("%d\n",sum);
	}else{
		printf("KHONG CO LOI GIAI\n");
	}
	return 0;
}

/cau 1

#include<stdio.h>
#define MAX_Vertices 100

typedef struct{
	int n,m;
	int A[MAX_Vertices][MAX_Vertices];
}Graph;

void init_graph(Graph *G, int n){
	G->n = n;
	int i,j;
	for(i = 1; i <= G->n; i++){
		for(j = 1; j <= G->n; j++){
			G->A[i][j] =0;
		}
	}
}

void add_edge(Graph *G, int x, int y){
	G->A[x][y] += 1;
	G->m++;
}
int degree(Graph *G, int x){
	int deg = 0;
	int i;
	for(i = 1; i <= G->n; i++){
		if(G->A[i][x] > 0){
			deg+=G->A[i][x];
		}
	}
	return deg;
}

int main(){
	Graph G;
	int n;
	scanf("%d",&n);
	init_graph(&G, n);
	int i,j;
	for(i = 1; i <= n; i++){
		for(j = 1; j <= n; j++){
			int a;
			scanf("%d ", &a);
			int e;
			for(e = 0; e < a; e++){
				add_edge(&G, i,j);
			}
		}
	}

	int max = 0, index = 0;
	for(i = 1; i <= n; i++){	
		if(max < degree(&G,i)){
			max = degree(&G,i);
			index = i;
		}			
	}
	printf("%d has received %d email(s).", index,max);

	return 0;
}