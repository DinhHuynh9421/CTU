#Một công ty ABC lập kế hoạch xây dựng một mạng truyền thông nối các trung tâm máy tính với nhau. Bất kỳ hai trung tâm nào cũng có thể được nối kết với nhau bằng
 đường điện thoại. Cần phải kết nối như thế nào để đảm bảo giữa hai trung tâm máy tính bất kỳ luôn có đường truyền thông sao cho tổng số tiền thuê bao 
của toàn mạng là tối thiểu? Giả sử chi phí (tính bằng $) giữa hai trung tâm được cho trong tập dữ liệu đầu vào từ dòng thứ 2 đến hết tập dữ liệu.  

#Viết chương trình để trả lời câu hỏi trên và in ra màn hình tổng số tiền thuê bao tối thiểu của toàn mạng.

#Đầu vào:

#Dữ liệu đầu vào đọc dữ liệu từ tập tin với định dạng

#- Dòng đầu tiên chứa 2 số nguyên n và m, tương ứng là số đỉnh và số cung.

#- m dòng tiếp theo mỗi dòng chứa 3 số nguyên u, v, w mô tả cung (u, v) có trọng số w.

#Đầu ra:

#In ra màn hình tổng chi phí.

#include <stdio.h>
#define MAX_N 100
#define NO_EDGE -1
typedef struct {
    int A[MAX_N][MAX_N];
    int n, m;
}Graph;

void init_graph(Graph *G, int n) {
    G->n=n;
    G->m=0;
    int u, v;
    for (u=1;u<=n;u++)
        for (v=1;v<=n;v++)
            G->A[u][v]=NO_EDGE;
}

void add_edge(Graph *G, int u, int v, int w) {
    G->A[u][v]=w;
    G->A[v][u]=w;
    G->m++;
}

#define oo 9999999
int mark[MAX_N], pi[MAX_N], p[MAX_N];

int Prim(Graph *G, Graph *T, int x) {
    int u, v, i;
    for (u=1;u<=G->n;u++) {
        mark[u] = 0;
        pi[u] = oo;
        p[u] = -1;
    }
    
    pi[x] = 0;
    
    for (i=1;i<G->n;i++) {
        int min_dist = oo;
        for (v=1;v<=G->n;v++)
            if (mark[v] == 0 && pi[v] < min_dist) {
                min_dist = pi[v];
                u = v;
            }
            
        mark[u] = 1;
        
        for (v=1;v<=G->n;v++)
            if (G->A[u][v]!=NO_EDGE && mark[v]==0)
                if (G->A[u][v] < pi[v]) {
                    pi[v] = G->A[u][v];
                    p[v] = u;
                }
    }
    
    init_graph(T, G->n);
    int sum_w = 0;
    for (u=1;u<=G->n;u++)
        if (p[u]!=-1) {
            add_edge(T, p[u], u, G->A[p[u]][u]);
            sum_w += G->A[p[u]][u];
        }
        
    return sum_w;
}

int main() {
    Graph G, T;
	int n, m, u, v, w, e;
	scanf("%d%d", &n, &m);
	init_graph(&G, n);
	
	for (e = 0; e < m; e++) {
		scanf("%d%d%d", &u, &v, &w);
		add_edge(&G, u, v, w);
	}
	
	int sum = Prim(&G, &T, 1);
	printf("$%d", sum);
	return 0;
}